#pragma once
#include "general_hooks.h"
#include <algorithm>
#include <ranges>
#include <array>


/* ---------- Minimal GL/CUDA typedefs ---------- */


/* ---------- Function pointer types for OpenGL ---------- */
using glDrawArrays_fptr     = void (*)(GLenum mode, GLint first, GLsizei count);
using glDrawElements_fptr   = void (*)(GLenum, GLsizei, GLenum, const void*);
using glUseProgram_fptr     = void (*)(GLuint);
using glBindBuffer_fptr     = void (*)(GLenum, GLuint);
using glBufferData_fptr     = void (*)(GLenum, std::size_t, const void*, GLenum);
using glCreateShader_fptr   = GLuint (*)(GLenum);
using glShaderSource_fptr = void (*)(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);
using glCompileShader_fptr  = void (*)(GLuint);
using glClear_fptr          = void (*)(GLuint);
using glBegin_fptr          = void (*)(GLenum);
using glEnd_fptr            = void (*)(void);
using glVertex3f_fptr       = void (*)(float, float, float);
using glXSwapBuffers_fptr   = void (*)(void*, void*);
using glXGetProcAddress_fptr = void* (*)(const GLubyte*);
using glPushMatrix_fptr = void (*)(void);
using glPopMatrix_fptr = void (*)(void);
using glRotatef_fptr = void (*)(float, float, float, float);
using glTranslatef_fptr = void (*)(float, float, float);
using glCallList_fptr = void (*)(unsigned int);
using glNormal3f_fptr = void (*)(float, float, float);
using glShadeModel_fptr = void (*)(unsigned int);

using __GLXextFuncPtr = void (*)(void);

using Display = struct _XDisplay;
using GLXDrawable = unsigned long;

// Function pointer types
using glXGetCurrentContext_fptr = GLXContext (*)(void);
using glXGetCurrentDrawable_fptr = GLXDrawable (*)(void);
using glXQueryExtensionsString_fptr = const char* (*)(Display*, int);
using glXSwapIntervalEXT_fptr = void (*)(Display*, GLXDrawable, int);
using glXSwapIntervalSGI_fptr = int (*)(int);
using glXCreateContextAttribsARB_fptr = GLXContext (*)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
using glXChooseFBConfig_fptr = GLXFBConfig* (*)(Display*, int, const int*, int*);
using glGetString_fptr = const GLubyte* (*)(GLenum);
using glGetStringi_fptr = const GLubyte* (*)(GLenum, GLuint);
using glGetIntegerv_fptr = void (*)(GLenum, GLint*);
using glXChooseVisual_fptr = XVisualInfo* (*)(Display*, int, int*);
using glXCreateContext_fptr = GLXContext (*)(Display*, XVisualInfo*, GLXContext, Bool);
using glXDestroyContext_fptr = void (*)(Display*, GLXContext);
using glXMakeCurrent_fptr = Bool (*)(Display*, GLXDrawable, GLXContext);
using glXQueryDrawable_fptr = void (*)(Display*, GLXDrawable, int, unsigned int*);

using glDrawElementsInstanced_fptr = void (*)(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount);
using glDrawElementsBaseVertex_fptr = void (*)(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex);
using glDrawRangeElements_fptr = void (*)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
using glMultiDrawElementsIndirect_fptr = void (*)(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride);
using glDrawElementsIndirect_fptr = void (*)(GLenum mode, GLenum type, const void* indirect);
using glXGetProcAddress_fptr = void* (*)(const GLubyte*);
using glXGetProcAddressARB_fptr = void* (*)(const GLubyte*);

using glFinish_fptr = void (*)(void);
using glFlush_fptr = void (*)(void);

using glXGetVisualFromFBConfig_fptr = GLXVisualInfo* (*)(Display* dpy, GLXFBConfig config);
using glActiveTexture_fptr = void (*)(GLenum texture);
using glAttachShader_fptr = void (*)(GLuint program, GLuint shader);
using glBindAttribLocation_fptr = void (*)(GLuint program, GLuint index, const GLchar* name);
using glBindFramebuffer_fptr = void (*)(GLenum target, GLuint framebuffer);
using glBindRenderbuffer_fptr = void (*)(GLenum target, GLuint renderbuffer);
using glBindTexture_fptr = void (*)(GLenum target, GLuint texture);
using glBlendEquation_fptr = void (*)(GLenum mode);
using glBlendEquationSeparate_fptr = void (*)(GLenum modeRGB, GLenum modeAlpha);
using glBlendFuncSeparate_fptr = void (*)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
using glBufferSubData_fptr = void (*)(GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
using glCheckFramebufferStatus_fptr = GLenum (*)(GLenum target);
using glClearColor_fptr = void (*)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
using glClearDepthf_fptr = void (*)(GLfloat depth);
using glClearStencil_fptr = void (*)(GLint s);
using glColorMask_fptr = void (*)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
using glCompressedTexImage2D_fptr = void (*)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
using glCompressedTexSubImage2D_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
using glCopyTexImage2D_fptr = void (*)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
using glCopyTexSubImage2D_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
using glCreateProgram_fptr = GLuint (*)();
using glCullFace_fptr = void (*)(GLenum mode);
using glDeleteBuffers_fptr = void (*)(GLsizei n, const GLuint* buffers);
using glDeleteFramebuffers_fptr = void (*)(GLsizei n, const GLuint* framebuffers);
using glDeleteProgram_fptr = void (*)(GLuint program);
using glDeleteRenderbuffers_fptr = void (*)(GLsizei n, const GLuint* renderbuffers);
using glDeleteShader_fptr = void (*)(GLuint shader);
using glDeleteTextures_fptr = void (*)(GLsizei n, const GLuint* textures);
using glDepthFunc_fptr = void (*)(GLenum func);
using glDepthMask_fptr = void (*)(GLboolean flag);
using glDetachShader_fptr = void (*)(GLuint program, GLuint shader);
using glDisable_fptr = void (*)(GLenum cap);
using glDisableVertexAttribArray_fptr = void (*)(GLuint index);
using glIsEnabled_fptr = GLboolean (*)(GLenum cap);
using glEnable_fptr = void (*)(GLenum cap);
using glEnableVertexAttribArray_fptr = void (*)(GLuint index);
using glFramebufferRenderbuffer_fptr = void (*)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
using glGetRenderbufferParameteriv_fptr = void (*)(GLenum target, GLenum pname, GLint* params);
using glFramebufferTexture2D_fptr = void (*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
using glFramebufferTexture3D_fptr = void (*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
using glFrontFace_fptr = void (*)(GLenum mode);
using glGenBuffers_fptr = void (*)(GLsizei n, GLuint* buffers);
using glGenerateMipmap_fptr = void (*)(GLenum target);
using glGenFramebuffers_fptr = void (*)(GLsizei n, GLuint* framebuffers);
using glGenRenderbuffers_fptr = void (*)(GLsizei n, GLuint* renderbuffers);
using glGenTextures_fptr = void (*)(GLsizei n, GLuint* textures);
using glGetActiveAttrib_fptr = void (*)(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
using glGetActiveUniform_fptr = void (*)(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
using glGetAttribLocation_fptr = GLint (*)(GLuint program, const GLchar* name);
using glGetError_fptr = GLenum (*)();
using glGetFramebufferAttachmentParameteriv_fptr = void (*)(GLenum target, GLenum attachment, GLenum pname, GLint* params);
using glGetProgramiv_fptr = void (*)(GLuint program, GLenum pname, GLint* params);
using glGetProgramInfoLog_fptr = void (*)(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
using glValidateProgram_fptr = void (*)(GLuint program);
using glGetShaderiv_fptr = void (*)(GLuint shader, GLenum pname, GLint* params);
using glGetShaderSource_fptr = void (*)(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source);
using glGetShaderInfoLog_fptr = void (*)(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
using glGetShaderPrecisionFormat_fptr = void (*)(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
using glGetTexParameteriv_fptr = void (*)(GLenum target, GLenum pname, GLint* params);
using glGetTexLevelParameterfv_fptr = void (*)(GLenum target, GLint level, GLenum pname, GLfloat* params);
using glGetTexLevelParameteriv_fptr = void (*)(GLenum target, GLint level, GLenum pname, GLint* params);
using glGetUniformiv_fptr = void (*)(GLuint program, GLint location, GLint* params);
using glGetUniformLocation_fptr = GLint (*)(GLuint program, const GLchar* name);
using glGetVertexAttribiv_fptr = void (*)(GLuint index, GLenum pname, GLint* params);


using glLinkProgram_fptr = void (*)(GLuint program);
using glPixelStorei_fptr = void (*)(GLenum pname, GLint param);
using glPolygonOffset_fptr = void (*)(GLfloat factor, GLfloat units);
using glReadPixels_fptr = void (*)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
using glRenderbufferStorage_fptr = void (*)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
using glScissor_fptr = void (*)(GLint x, GLint y, GLsizei width, GLsizei height);
using glStencilFuncSeparate_fptr = void (*)(GLenum face, GLenum func, GLint ref, GLuint mask);
using glStencilMask_fptr = void (*)(GLuint mask);
using glStencilOpSeparate_fptr = void (*)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
using glTexImage2D_fptr = void (*)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
using glTexImage2DMultisample_fptr = void (*)(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
using glTexParameterf_fptr = void (*)(GLenum target, GLenum pname, GLfloat param);
using glTexParameteri_fptr = void (*)(GLenum target, GLenum pname, GLint param);
using glTexParameteriv_fptr = void (*)(GLenum target, GLenum pname, const GLint* params);
using glTexSubImage2D_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
using glUniform1fv_fptr = void (*)(GLint location, GLsizei count, const GLfloat* value);
using glUniform1i_fptr = void (*)(GLint location, GLint v0);
using glUniform1iv_fptr = void (*)(GLint location, GLsizei count, const GLint* value);
using glUniform1uiv_fptr = void (*)(GLint location, GLsizei count, const GLuint* value);
using glUniform2fv_fptr = void (*)(GLint location, GLsizei count, const GLfloat* value);
using glUniform2iv_fptr = void (*)(GLint location, GLsizei count, const GLint* value);
using glUniform2uiv_fptr = void (*)(GLint location, GLsizei count, const GLuint* value);
using glUniform3fv_fptr = void (*)(GLint location, GLsizei count, const GLfloat* value);
using glUniform3iv_fptr = void (*)(GLint location, GLsizei count, const GLint* value);
using glUniform3uiv_fptr = void (*)(GLint location, GLsizei count, const GLuint* value);
using glUniform4fv_fptr = void (*)(GLint location, GLsizei count, const GLfloat* value);
using glUniform4iv_fptr = void (*)(GLint location, GLsizei count, const GLint* value);
using glUniform4uiv_fptr = void (*)(GLint location, GLsizei count, const GLuint* value);
using glUniformMatrix3fv_fptr = void (*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glUniformMatrix4fv_fptr = void (*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glVertexAttrib4f_fptr = void (*)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
using glVertexAttrib4fv_fptr = void (*)(GLuint index, const GLfloat* v);
using glVertexAttribPointer_fptr = void (*)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
using glViewport_fptr = void (*)(GLint x, GLint y, GLsizei width, GLsizei height);
using glGenQueries_fptr = void (*)(GLsizei n, GLuint* ids);
using glDeleteQueries_fptr = void (*)(GLsizei n, const GLuint* ids);
using glBeginQuery_fptr = void (*)(GLenum target, GLuint id);
using glEndQuery_fptr = void (*)(GLenum target);
using glGetQueryiv_fptr = void (*)(GLenum target, GLenum pname, GLint* params);
using glGetQueryObjectuiv_fptr = void (*)(GLuint id, GLenum pname, GLuint* params);
using glBindVertexArray_fptr = void (*)(GLuint array);
using glIsVertexArray_fptr = GLboolean (*)(GLuint array);
using glDeleteVertexArrays_fptr = void (*)(GLsizei n, const GLuint* arrays);
using glGenVertexArrays_fptr = void (*)(GLsizei n, GLuint* arrays);
using glTexImage3D_fptr = void (*)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
using glTexSubImage3D_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
using glCompressedTexSubImage3D_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
using glCompressedTexImage3D_fptr = void (*)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
using glTexStorage2D_fptr = void (*)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
using glTexStorage3D_fptr = void (*)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
using glBlitFramebuffer_fptr = void (*)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
using glRenderbufferStorageMultisample_fptr = void (*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
using glGetIntegeri_v_fptr = void (*)(GLenum target, GLuint index, GLint* data);
using glMapBufferRange_fptr = void* (*)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
using glUnmapBuffer_fptr = GLboolean (*)(GLenum target);
using glFlushMappedBufferRange_fptr = void (*)(GLenum target, GLintptr offset, GLsizeiptr length);
using glInvalidateFramebuffer_fptr = void (*)(GLenum target, GLsizei numAttachments, const GLenum* attachments);
using glDrawArraysInstanced_fptr = void (*)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
using glCopyBufferSubData_fptr = void (*)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
using glDrawBuffers_fptr = void (*)(GLsizei n, const GLenum* bufs);
using glReadBuffer_fptr = void (*)(GLenum src);
using glFramebufferTextureLayer_fptr = void (*)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
using glFramebufferTexture_fptr = void (*)(GLenum target, GLenum attachment, GLuint texture, GLint level);
using glBindBufferBase_fptr = void (*)(GLenum target, GLuint index, GLuint buffer);
using glBindBufferRange_fptr = void (*)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
using glGetActiveUniformsiv_fptr = void (*)(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
using glGetUniformBlockIndex_fptr = GLuint (*)(GLuint program, const GLchar* uniformBlockName);
using glGetUniformIndices_fptr = void (*)(GLuint program, GLsizei uniformCount, const GLchar* const* uniformNames, GLuint* uniformIndices);
using glGetActiveUniformBlockiv_fptr = void (*)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
using glGetActiveUniformBlockName_fptr = void (*)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
using glUniformBlockBinding_fptr = void (*)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
using glVertexAttribIPointer_fptr = void (*)(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
using glGetProgramBinary_fptr = void (*)(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
using glProgramBinary_fptr = void (*)(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
using glProgramParameteri_fptr = void (*)(GLuint program, GLenum pname, GLint value);
using glGenSamplers_fptr = void (*)(GLsizei count, GLuint* samplers);
using glDeleteSamplers_fptr = void (*)(GLsizei count, const GLuint* samplers);
using glBindSampler_fptr = void (*)(GLuint unit, GLuint sampler);
using glSamplerParameteri_fptr = void (*)(GLuint sampler, GLenum pname, GLint param);
using glGetInternalformativ_fptr = void (*)(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
using glFenceSync_fptr = GLsync (*)(GLenum condition, GLbitfield flags);
using glClientWaitSync_fptr = GLenum (*)(GLsync sync, GLbitfield flags, GLuint64 timeout);
using glDeleteSync_fptr = void (*)(GLsync sync);
using glClearBufferuiv_fptr = void (*)(GLenum buffer, GLint drawbuffer, const GLuint* value);
using glClearBufferfv_fptr = void (*)(GLenum buffer, GLint drawbuffer, const GLfloat* value);
using glClearBufferfi_fptr = void (*)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
using glProgramUniform1fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLfloat* value);
using glProgramUniform1iv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLint* value);
using glProgramUniform2fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLfloat* value);
using glProgramUniform2iv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLint* value);
using glProgramUniform3fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLfloat* value);
using glProgramUniform3iv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLint* value);
using glProgramUniform4fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLfloat* value);
using glProgramUniform4iv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLint* value);
using glProgramUniformMatrix2fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix3fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix4fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix2x3fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix3x2fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix2x4fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix4x2fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix3x4fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniformMatrix4x3fv_fptr = void (*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
using glProgramUniform1uiv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLuint* value);
using glProgramUniform2uiv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLuint* value);
using glProgramUniform3uiv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLuint* value);
using glProgramUniform4uiv_fptr = void (*)(GLuint program, GLint location, GLsizei count, const GLuint* value);
using glBindImageTexture_fptr = void (*)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
using glDispatchCompute_fptr = void (*)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
using glDispatchComputeIndirect_fptr = void (*)(GLintptr indirect);
using glGetProgramInterfaceiv_fptr = void (*)(GLuint program, GLenum programInterface, GLenum pname, GLint* params);
using glGetProgramResourceName_fptr = void (*)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
using glGetProgramResourceiv_fptr = void (*)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params);
using glGetProgramResourceIndex_fptr = GLuint (*)(GLuint program, GLenum programInterface, const GLchar* name);
using glDrawArraysIndirect_fptr = void (*)(GLenum mode, const void* indirect);
using glMemoryBarrier_fptr = void (*)(GLbitfield barriers);
using glPatchParameteri_fptr = void (*)(GLenum pname, GLint value);
using glCopyImageSubData_fptr = void (*)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
using glTexStorage3DMultisample_fptr = void (*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
using glDrawElementsInstancedBaseVertex_fptr = void (*)(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex);
using glBlendFuncSeparatei_fptr = void (*)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
using glBlendEquationi_fptr = void (*)(GLuint buf, GLenum mode);
using glBlendEquationSeparatei_fptr = void (*)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
using glColorMaski_fptr = void (*)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
using glGetQueryObjectui64v_fptr = void (*)(GLuint id, GLenum pname, GLuint64* params);
using glDrawBuffer_fptr = void (*)(GLenum buf);
using glPolygonMode_fptr = void (*)(GLenum face, GLenum mode);
using glClearDepth_fptr = void (*)(GLdouble depth);
using glGetTextureParameteriv_fptr = void (*)(GLuint texture, GLenum pname, GLint* params);
using glGetTextureLevelParameteriv_fptr = void (*)(GLuint texture, GLint level, GLenum pname, GLint* params);
using glRenderbufferStorageMultisampleEXT_fptr = void (*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
using glFramebufferTexture2DMultisampleEXT_fptr = void (*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);

using glDebugMessageControl_fptr = void (*)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
using glDebugMessageCallback_fptr = void (*)(GLDEBUGPROC callback, const void* userParam);
using glDebugMessageInsert_fptr = void (*)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
using glObjectLabel_fptr = void (*)(GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
using glGetObjectLabel_fptr = void (*)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label);
using glPushDebugGroup_fptr = void (*)(GLenum source, GLuint id, GLsizei length, const GLchar* message);
using glPopDebugGroup_fptr = void (*)();
using glPushGroupMarkerEXT_fptr = void (*)(GLsizei length, const GLchar* marker);
using glPopGroupMarkerEXT_fptr = void (*)();
using glLabelObjectEXT_fptr = void (*)(GLenum type, GLuint object, GLsizei length, const GLchar* label);
using glGetObjectLabelEXT_fptr = void (*)(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label);
using glTexBuffer_fptr = void (*)(GLenum target, GLenum internalformat, GLuint buffer);
using glTextureView_fptr = void (*)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
using glTexPageCommitmentARB_fptr = void (*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
using glBlendBarrierKHR_fptr = void (*)();
using glTexStorage2DMultisample_fptr = void (*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);


glXGetProcAddress_fptr glXGetProcAddress_fptr_resolved = nullptr;
glXGetProcAddressARB_fptr glXGetProcAddressARB_fptr_resolved = nullptr;
